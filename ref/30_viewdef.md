# View deffinition

Views are representation of underlying data structure based on requirements set by 
business logic. Views are used to define how data is presented, saved, deleted.

Where possible view definition is implied and generated from table definition (see [Table definition](ref/20_tabledef.md)) 
and function signatures (see [Function signatures](ref/14_function_signatures.md)).

**TODO** talk about keys

## General  structure

[Yaml 1.2](https://yaml.org/spec/1.2/) syntax is used for view metadata, but some keys and values are further parsed by mojoz and empty line is used as delimiter.
Key names are:

* **name** - view name
* **table** - table name
* **comments** - view comments
* **api** - collection of APIs view is used for
* **auth** - auth filter statement for horizontal data access control
* **joins** - collection of join statements
* **fields** - collection of fields
* **filter** - collection of filter statements
* **order** - collection of order statements

All the statements are written in tresql syntax, and the 
resulting select, insert, update delete statements are generated by mojoz are as well.

for example, view definition

**TODO test this example**

```yaml
name: user
table: users
comments: This view provides basic users data
api: list, count
fields:
  - id
  - full_name = concat_ws(' ', u.name, u.surname)
filter:
  - email
```

corresponds to following sql: 

```sql
SELECT id, CONCAT_WS(' ', name, surname) AS full_name FROM users WHERE email = ?

SELECT count(*) FROM users WHERE email = ?
```

and savable view: 

**TODO test this example**
```yaml
name: user
table: users
comments: This view provides basic users data
api: save get delete
fields:
  - id
  - name
  - surname
  - email
  - date_of_birth
```

corresponds to following sql: 
    
```sql
SELECT id, name, surname, email, date_of_birth FROM users WHERE id = ?

INSERT INTO users (id, name, surname, email, date_of_birth) VALUES (nextval('seq') ?, ?, ?, ?)

UPDATE users SET name = ?, surname = ?, email = ?, date_of_birth = ? WHERE id = ?
```

## Structure

### Name

View name is used to identify view in the system. It is used in REST API calls and in scala code.

### Table

Name and alias of the main table.

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank clients with their details
  - Must be accessible only to users with role `manage_bank_clients`
fields:
  - id
  - name
  - address
  - phone
  - email
  - last_activity = greatest(date_created, date_updated, last_login) : Last activity
  - initials = substring(name, 1, 1) || substring(surname, 1, 1) : Initials
```
results in 

```sql
select 
  c.id, 
  c.name, 
  c.address, 
  c.phone, 
  c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
limit 101

select count(*) from client c
```

### Comments

List of comments for view that can be included in api documentation or just document the code.

```yaml
name: user_list
table: adm_user l
api: logged_in_user list, logged_in_user count
comments: List of users with their details
```

comments can be multiline as well:

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank clients with their details
  - Must be accessible only to users with role `manage_bank_clients`
```

### Api

List of API methods supported by view and permission required. Possible values are:

* list - list array of records, default rest path is `/data/{view_name}`
* count - count number of records, default rest path is `/data/count/{view_name}` or `/data/count:{view_name}`
* get - get single record, default rest path is `/data/{view_name}/{id}`
* save - save record, default rest path is `/data/{view_name}` POST for insert and `/data/{view_name}/id` PUT for update
* delete - delete record, default rest path is `/data/{view_name}/{id}` DELETE
* create - create record, default rest path is `/data/create/{view_name}` or `/data/create:{view_name}`

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count

name: send_message
table: messages m
api: logged_in_user insert,  logged_in_user get
comments: Send a message to another user

name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count
comments: List of messages sent by the logged in user
```

If api is set to empty, then view is not accessible via REST API directly, but can be used in other views.:

```yaml
name: client_account
table: account a
api:
fields:
  - id
  - balance
  - currency

name: bank_client
table: client c
fields:
  - id
  - name
  - surname
  - accounts * client_account:
```

### Auth

Auth filter statement for the horizontal data access control statement is added to where clause of the select statement. 

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
auth delete: sender_id = :current_user_id & is_read = false
comments: List of messages sent by the logged in user
joins:
  - m [m.attachment_id = f.id] file_info f?
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
  - attachment = f.filename
filter:
  - message %~~~% :message_contains?
```

results in 

```sql
select 
  m.id, 
  (select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver,
  m.subject, 
  m.message, 
  m.time, 
  m.is_read, 
  f.filename as attachment 
from messages m 
left join file_info f on m.attachment_id = f.id 
where (lower(f_unaccent(message)) like '%' || lower(f_unaccent(?/*message_contains*/)) || '%') 
and (sender_id = ?/*current_user_id*/) 
limit ?/*1*/

select count(*) from messages m where (sender_id = ?/*current_user_id*/)

delete from messages m where id = 125 and ((sender_id = 8 and is_read = false))
```

This works for insert and update as well:

```yaml
name: bank_account
table: account a
api: manage_bank_clients list, manage_bank_clients count, manage_bank_clients get, manage_bank_clients save, manage_bank_clients delete
auth save delete: exists(client_manager cm[cm.client_id = a.client_id & cm.user_id = :current_user_id]{1})
comments:
  - List of bank accounts with their details
  - Must be accessible only to users with role `manage_bank_clients`
fields:
  - id
  - client_id
  - number  [+]:
  - balance [+]:
      - field api: readonly
  - currency
  - type
  - date_created [+]:
      - field api: readonly
  - date_closed
insert:
  - date_created = now()
  - balance = 0.0
  - insert this
```

results into:

```sql
insert into account (client_id, number, balance, currency, type, date_created, date_closed, id) 
select a.client_id, a.number, a.balance, a.currency, a.type, a.date_created, a.date_closed, a.id 
from (select 
  ?/*client_id*/::bigint as client_id, 
  ?/*number*/::text as number,
  ?/*balance*/::numeric(12, 2) as balance, 
  ?/*currency*/::text as currency, 
  ?/*type*/::text as type, 
  ?/*date_created*/::date as date_created, 
  ?/*date_closed*/::date as date_closed, 
  ?/*#account:id*/::bigint as id limit 1
  ) a 
where (exists(select 1 from client_manager cm where cm.client_id = a.client_id and cm.user_id = ?/*current_user_id*/))

update account a set 
  client_id = ?/*client_id*/, 
  currency = ?/*currency*/, 
  type = ?/*type*/, 
  date_closed = ?/*date_closed*/ 
where id = ?/*:#account:id*/ 
and ((exists(select 1 from client_manager cm where cm.client_id = a.client_id and cm.user_id = ?/*current_user_id*/)))
```

### Joins

Collection of join statements in tresql syntax. 

```yaml
name: bank_account_list
table: account a
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank accounts with their details
  - Must be accessible only to users with role `manage_bank_clients`
joins:
  - a [a.client_id = c.id] client c
fields:
  - id
  - number
  - balance
  - currency
  - type
  - client_name = c.name || ' ' || c.surname
```

results in 

```sql
select 
  a.id, 
  a.number, 
  a.balance, 
  a.currency, 
  a.type, 
  c.name || ' ' || c.surname as client_name 
from account a 
join client c on a.client_id = c.id 
limit ?/*1*/
```

If left join is required, then the question mark is added to join statement:

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
auth delete: sender_id = :current_user_id & is_read = false
comments: List of messages sent by the logged in user
joins:
  - m [m.attachment_id = f.id] file_info f?
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
  - attachment = f.filename
filter:
  - message %~~~% :message_contains?
```

results in

```sql
select 
  m.id, 
  (select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver,
  m.subject, 
  m.message, 
  m.time, 
  m.is_read, 
  f.filename as attachment 
from messages m 
left join file_info f on m.attachment_id = f.id 
where (lower(f_unaccent(message)) like '%' || lower(f_unaccent(?/*message_contains*/)) || '%') 
and (sender_id = ?/*current_user_id*/) 
limit ?/*1*/
```

If there is only one between tables, then it can be omitted:

```yaml
joins:
  - a / client c
```

Then whether join is left or inner is inferred from table definition - 
if foreign key is nullable, then left join is used, otherwise inner join is used.
However, the join type can be specified explicitly:

* `!` - inner join
* `?` - left join

```yaml
joins:
  - a / client c?
```

or

```yaml
joins:
  - a / client c!
```


### Fields

List of fields withing the view.

```yaml
name: bank_client
table: client c
fields:
  - id
  - name
  - surname
  - address
  - phone
  - email
```

In this case, a type of field is inferred from table definition.

If a necessary field type can be specified explicitly:

```yaml
name: bank_client
table: client c
fields:
  - id        integer
  - name      string
  - surname   string
  - address   string
  - phone     string
  - email     string
  - balance   balance = (account a[a.client_id = c.id]{sum(a.balance)}) : Total balance 
```

See [Column definition](20_tabledef.md) for more details on type definition.

#### Calculated fields

Calculated fields are fields that are not directly mapped to table columns but are calculated from other fields.

```yaml
name: bank_client
table: client c
fields:
  - id        integer
  - balance   balance = (account a[a.client_id = c.id]{sum(a.balance)}) : Total balance 
```

```yaml
name: message_receiver_choice
table: adm_user u
api: logged_in_user list
comments: List of users for user selection
fields:
  - id
  - text = u.name || ' ' || u.surname || ' (' || u.email || ')'
filter:
  - ^text %~~~% :text?
```

Calculated field can be used in a save statement as well to store back value sent by client.

**TODO test this example**

```yaml
name: account
table: account
joins: 
  - account [account.bank_id = bank.id] bank
fields:
- id
- code = bank.code -> bank_id = bank[code = :code]{id}
```

Both expressions can be taken from separate view definitions

```yaml
name: message_receiver_choice
table: adm_user u
api: logged_in_user list
comments: List of users for user selection
fields:
  - id
  - text = u.name || ' ' || u.surname || ' (' || u.email || ')'
filter:
  - ^text %~~~% :text?

name: send_message
table: messages m
api: logged_in_user insert,  logged_in_user get
comments: Send a message to another user
fields:
  - id
  - receiver = ^message_receiver_choice.text -> = ^message_receiver_choice[^text = _]{id}
  - sender_id:
      - field api: excluded
  - subject
  - message
save:
  - sender_id = :current_user_id
  - save this
```

**TODO** List all shortcut syntaxes for calculated fields

> bank_id nevajag rakstīt ja forenā kāja saucas "code" + "_id"
> "_" ir shorthand priekš ":code"
> Vēl ir "dati json = -> = _" gadijums, varbūt strādā tapēc ka nav tāda "dati_id"

#### Field properties

Besides field name and type, field properties can be specified as well. 

##### Access control

**FIXME field db removed, [!]  [+]** 

For access control, fields can be fine-tuned: 
Wabase defines two interfaces for fields: 

* between browser and backend `field api`
* between backend and db `field db`

They can be marked as 

* `readonly` - no insert, no update, only return in response
* `no insert` - no insert, but can be updated
* `no update` - can be inserted, but not updated
* `excluded` - not returned in interface

For example,

**TODO test this example**

```yaml
fields:
  - code:
    - field api: readonly
      field db: no update
  - name:
```

Can not be updated from browser, but can be updated from backend on insert.

**TODO** - add more examples


Specific case 'readonly: true' means both interfaces are readonly, these fields have the same access control. 
In this example both fields are readonly for both interfaces.

**TODO test this example**

```yaml
fields:
  - code:
    - field api: readonly
      field db: readonly
  - name:
    - readonly: true
```

##### Sorting

Fields can be marked as sortable, which means they can be used in a sort statement in list calls.
Doe to possible risks of performance hit not all fields are sortable by default,
user can request only fields that are marked as sortable.

Given this example:

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank clients with their details
  - Must be accessible only to users with role `manage_bank_clients`
fields:
  - id
  - name:
      - sortable: true
  - address
  - phone
  - email:
      - sortable: true
  - last_activity = greatest(date_created, date_updated, last_login) :
      - Last activity
      - sortable: true
  - initials = substring(name, 1, 1) || substring(surname, 1, 1) :
      - Initials
      - sortable: true
order:
  - id
```

Calling:

```http://localhost:8090/data/bank_client_list```

Will result in:
    
```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
order by id asc 
limit 101
```

Calling 

```http://localhost:8090/data/bank_client_list?sort=name```

Will result in:

```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
order by name asc, id asc 
limit 101
```
You can use multiple fields in sort statement:

```http://localhost:8090/data/bank_client_list?sort=name,email```

Will result in:

```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c order by name asc, email asc, id asc 
limit 101
```

You can use calculated fields in sort statement as well:

```http://localhost:8090/data/bank_client_list?sort=last_activity```

Will result in:

```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initial
from client c order by last_activity asc, id asc 
limit 101
```

But calling unsortable field will result in error:

```http://localhost:8090/data/bank_client_list?sort=address```

Will result in:

```
400
Bad Request
Not sortable: bank_client_list by address
```
##### Initial value

Initial value statement can be provided. It will be called when view create api call is called:

**TODO test this example**

```yaml
fields:
  - created_at:
    - initial: now()
```

##### Extended properties

Any other properties can be added to field definition and are passed to field definition in mojoz.

**TODO** - add example


#### Substrcutures

Fields can have nested structures that are defined in separate view definitions. 

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - address [u.address_id = a.id]:
        table: addresses a
        fields:
        - street
        - city
        - country
```

then json returned by get api call will have nested structure:

```json
{
  "id": 1,
  "name": "John",
  "surname": "Doe",
  "address": {
    "street": "Main street",
    "city": "New York",
    "country": "USA"
  }
}
```

Save will be able to save nested structure as well.

If there is only one foreign key from users to address table, then it can be omitted:

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - address:
        table: addresses a
        fields:
        - street
        - city
        - country
```

Substructure can be a list of structures as well:

```yaml
name: client_account
table: account a
api:
fields:
  - id
  - number
  - balance
  - currency
  - type
  - date_created
  - date_closed

name: bank_client
table: client c
fields:
  - id
  - name
  - surname 
  - accounts * client_account:
```

Then json returned by get api call will have nested list of structures:

```json
{
  "id": 31,
  "name": "Ada",
  "surname": "Lovelace",
  "accounts": [
    {
      "id": 36,
      "number": "e8JptEWxkV",
      "balance": 123123,
      "currency": "USD",
      "type": "SAVINGS",
      "date_created": "2024-11-22",
      "date_closed": null
    }
  ]
}
```      

The Default behavior on save for nested lists of structures is to delete all existing records and insert new ones.
If you want to update existing records, specify it in view definition:

```yaml
name: bank_client
table: client c
fields:
  - id
  - name
  - surname
  - accounts [+-=]* client_account:
```

Flags in brackets specify behavior on save:

* `+` - insert new records
* `-` - delete records
* `=` - update records

For this to work, the primary key of nested structure must be provided in view definition and sent back by client.

### Filter

The Filter section is used to filter records in a list and count api calls. 

Developers can specify fields that can be used for filtering in a list and count api calls:

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
filter:
  - is_read
```

By default filter is not included in a select statement, but if a filter is provided in api call, then it is included:

Query 
```http://localhost:8090/data/sent_messages```

Results in:

```sql
select 
m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where (sender_id = 8) limit 101
```

But if filter is provided:

```http://localhost:8090/data/sent_messages?is_read=true```

Results in:

```sql
select 
m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where (m.is_read = true) 
and (sender_id = 8) limit 101
```

As it is with sorting fields,
only fields that are marked as filterable can be used in a filter statement since it can cause performance issues.


Custom filter statement can be provided as well:

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
filter:
  - message %~~~% :message_contains?
```

Results in:

```sql
select m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where 
(lower(f_unaccent(message)) like '%' || lower(f_unaccent('hello')) || '%') 
and (sender_id = 8) 
limit 101
```

Question mark is used to specify that filter is optional. Marking optional parameters can only go so far,
it only excludes statement parameter is used in.

For example this **bad** example:

```yaml
filter:
  - exists(adm_user a[a.id = m.receiver_id & a.email = :username?]{1})
```

Results in:

```sql
where (exists(select 1 from adm_user a where a.id = m.receiver_id)) 
```

or with parmeter:

```http://localhost:8090/data/sent_messages?username=cm%40localhost```


```sql
where (exists(select 1 from adm_user a where a.id = m.receiver_id and a.email = 'cm@localhost'))
```

Proper way to remove an unnecessary filter statement in this case is to use `if_defined` macro:

```yaml
filter:
  - if_defined(:username, exists(adm_user a[a.id = m.receiver_id & a.email = :username?]{1}))
```

Macros are called during sql creation and can be used to modify statement.
Now when username is not provided, a filter statement is not included:

```sql
where (sender_id = 8) 
limit 101
```

Query with parameter remains the same:


```sql
 where (exists(select 1 from adm_user a where a.id = m.receiver_id and a.email = 'cm@localhost')) 
 and (sender_id = 8) 
 limit 101
```


To make filter statements more expandable, there are more macros provided: 

* `if_defined` - if parameter is provided, then a filter statement is included
* `if_defined_or_else` - if parameter is provided, then a filter statement is included, else another statement is included
* `if_missing` - if parameter is not provided, then a filter statement is included
* `if_all_defined` - if all parameters are provided, then a filter statement is included
* `if_any_defined` - if any parameter is provided, then a filter statement is included
* `if_all_missing` - if all parameters are not provided, then a filter statement is included
* `if_any_missing` - if any parameter is not provided, then a filter statement is included

Examples:

```yaml
filter:
  - if_defined(:name_if_def, name = :name_if_def)
  - if_defined_or_else(:name_if_def_or_else, name = :name_if_def_or_else, true)
  - if_missing(:name_if_miss, true)
  - if_all_defined(:name_if_all_def, :surname_if_all_def, name = :name_if_all_def & surname = :surname_if_all_def)
```

### Order

Order section is used to sort records in list and count api calls if user has not provided fields that used in sorting.

Example: 

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
order:
    - name
    - surname
```

Result is 

```sql
select u.id, u.name, u.surname from users u order by u.name, u.surname
```

Order can be specified in descending order as well:

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
order:
    - ~name
    - surname
```

Result is 

```sql
select u.id, u.name, u.surname from users u order by u.name desc, u.surname
```

Expressions can be used in order as well, and previously defined custom fields:

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - age integer = date_part('year', now()) - date_part('year', u.date_of_birth)
order:
    - ^age
    - concat_ws(' ', u.name, u.surname)
```
Result is 

```sql
select u.id, u.name, u.surname from users u 
order by 
date_part('year', now()) - date_part('year', u.date_of_birth), 
concat_ws(' ', u.name, u.surname)
```

### Extended properties

Any other properties can be added to view definition and are passed to view definition in mojoz.

**TODO** - add example

## Actions

In addition to default save, list and other behaviors developer can extend them or completely override them by providing custom code.

Actions can be defined for following methods:

* get - get single record
* list - list array of records
* save - save record
* insert - insert record, if defined both save and insert, then insert is used for insert and save for update **TODO** test this
* update - update record, if defined both save and update, then update is used for update and save for insert **TODO** test this
* delete - delete record
* create - create record
* count - count number of records

Here is basic example of save action: 

**TODO test this example**

```yaml
name:     person
api:      save
table:    person
auth get: :update_enabled = true
fields:
- id
- name
- sex
- birthdate
save:
- name = :current_person_name
- sex  = 'M'
- save this
```

In this case, save action is used to override values of fields `name` and `sex` and then save record.

Save action is defined for view by giving set of steps to complete action. Each step is executed in declared order and can modify context in which action is executed. 


**TODO** add inline examples 

Awailable steps are:

* Evaluation - evaluate operation and assign it to variable in context (`name = :current_person_name`), **TODO** by default all operations are evaluations without assignment
* SetEnv - evaluate operation and override entire context where action is executed (`setenv {"JOHN" name, "DOE" surname}`)
* Return - return value from action (`return unique {"1234565" account_number}`), also terminates action if used in if block 
* Validations - validate data within context 
* RemoveVar - remove variable from context (`name -=`)

Within steps following operations can be used:


* tresql - execute tresql statement (`time = now()`)
* view call - do action for another view (`res = save person`)
* status - return http status code (`status ok {"Happy hour"}`, `status { 303, '/data', 'path', :status }`)
* redirect - redirect to another view, creates status 303 with location (`redirect {'person_health', :name, :manipulation_date::date, '?', 'val1' par1, 'val2' par2 }` creates location - `person_health/John/2020-01-01?val1=par1&val2=par2`)
* unique - extracts unique record from list, otherwise throws error (`person = unique { 'John' name, 'Doe' surname }`)
* unique_opt - extracts unique record from list, otherwise returns null (`person = unique_opt { 'John' name, 'Doe' surname }`)
* invocation - call scala or java method (`res = org.wabase.QuereaseActionTestManager.concatStrings`)
* variable transforms - assign value to variable (`return (count = :c) + (data = :d)`)
* foreach - foreach loop block
* if, else - if else blocks
* resource - reads file from classpath as `akka.util.ByteString` (`template = resource 'templates/person_template.txt'`)
* file - reads file from file streamer as `akka.util.ByteString` (`template = file 'templates/person_template.txt'`), see [File streamer](../misc/80_files.md) for more details
* to file - writes file to file streamer (`to file accounts{number} 'account_numbers' 'application/json'`), see [File streamer](../misc/80_files.md) for more details
* template - generate template (`template 'Hello {{name}}!'`)
* email - sends email (`email ({'foo@bar.com' 'to', 'FOO', name}) (template 'Hello') (template 'Hello {{name}}!')`)
* http - make http call (`res = http get {'/not_decode_request_insert_test', '?', 'value' name }`)
* http header - extracts header from original request (`header = extract header X-Forwarded-For`)
* db - can open connection to database if connections are not initialized by setting flag `explicit db: true`, (`transaction save this`) **TODO** document "explicit db"
* conf - read config parameter (`app_name = conf string app.name`) **TODO** document "conf"
* json codec - encode or decode json (`person_object = from json :json_string`) (`json_string = to json :person_object`)
* block - group of actions
* job - run predefined job. (`job_res = job test_job`) See [Scheduling](../misc/10_scheduling.md)
* commit - commit transaction  (`commit`)
* extract parts - extract request parts for manual processing (`res = extract parts`)

### Forming response

Return statement:

**TODO test this example**

```yaml
name: person_list
table: person
fields:
  - id
  - name
  - surname
  - sex
  - birthdate
filter:
  - name %~~%
  - surname %~~%
list:
  - c: count this   # named step supports also colon notation
  - d: list  this   # named step supports also colon notation
  - return (count = :c) + (data = :d)
```

Response as option from list

**TODO test this example**

```yaml
name: purchase_get
api: get
db: shop_db
table: purchase
fields:
  - customer
  - purchase_time
  - item
  - amount
get:
  - unique_opt |shop_db:purchase[purchase_time = :purchase_time & customer = :customer]
    {item, amount}
```

Returning variable as response:

**TODO test this example**

```yaml
name: invocation_test_1
table:
api: get, save, count, delete, create
fields:
- s1
- s2
- n1
- n2
get:
- setenv create this
- s3 = org.wabase.QuereaseActionTestManager.concatStrings
- status ok { :s3 }
```

Returning variable as response second example:

**TODO test this example**

```yaml
name: http_test_2
table:
key: name
api: get, list, save
fields:
- id
- name
- manipulation_date
- vaccine
get:
- unique {:name name, :manipulation_date::date manipulation_date, :vaccine vaccine, :id::long id}
list:
- res = http '/invocation_test_1'
- status ok :res
```

Redirect examples: 

**TODO test this example**

```yaml
name:   status_test_3
table:
api:    get, save, list, count
fields:
  - id
save:
  - status { 303 }
get:
  - redirect { 'data/path/' || :id }
list:
  - status { 303, 'data/path', :id, '?', 'val-of-par1' par1 }
count:
  - redirect { null, :id, '?', (:id + 1) par1 }
```

### View call

Example how to call view itself:

**TODO test this example**

```yaml
name: person_list
table: person
fields:
  - id
  - name
  - surname
  - sex
  - birthdate
filter:
  - name %~~%
  - surname %~~%
list:
  - c: count this   # named step supports also colon notation
  - d: list  this   # named step supports also colon notation
  - return (count = :c) + (data = :d)
```

**TODO** - is supper save action executed by default?

**TODO test this example**

```yaml
name: persona_base
table: person
fields:
  - id
  - name
save:
  - name = 'Mr ' || :name
  - save this
    
name: persona
extends: persona_base
fields:
  - surname
  - birthdate
save:
  - save persona_base
  - save this
```

**TODO** how to forward parameters to view call?, Martins thinks that it will work

**TODO test this example**

```yaml
name: do_audit
table: audit
fields:
  - id 
  - data
  - timestamp
save:
  - timestamp = now()
  - save this
    
name: persona
extends: persona_base
fields:
  - surname
  - birthdate
save:
  - (data = :surname) -> save do_audit
  - save this
```


**TODO** - discuss when permissions are checked

### Flow control

Foreach block allows you to iterate over list of items within context and execute block of statements for each item.
Within block context is changed to item in list, parent context can be accessed with `:'..'`.

**TODO** - should we talk about `build cursors`? 

**TODO test this example**

```yaml
name: foreach_test_1
table: if_and_foreach_test ift
api: get, save
key: code
fields:
- code
- parent
- value
- children[!] * [:1(code) = parent]foreach_test_1
save:
- insert this
- foreach :children :
    - parent = :'..'.code
    - insert this
- get this
update:
- update this
- foreach :children :
    - parent = :'..'.code
    - update this
- get this
```

If block allows to create conditional blocks of statements. 
If block contains else block as well then result can be returned from if block.

**TODO test this example**

```yaml
name: if_test_1
table: if_and_foreach_test
api: save, get, delete
fields:
- code
- parent
- value
save:
- code = 'if_test_1'
- if {:value = 'yes'} :
    - value = :value || '_value'
    - +if_and_foreach_test{code = :code, value = :value}
- if {:value = 'no'} :
    - value = :value || '_value'
    - =if_and_foreach_test[code = :code]{value = :value}
- unique_opt if_and_foreach_test[code = :code]{code, value}
get:
- result = if {:code = 'true'}:
  - unique { :code code, null parent, 'Value' value }
- else:
  - unique { :code code, null parent, 'Else value' value }
- :result
delete:
- result:
  - if {:code = 'true'}:
    - unique { :code code, null parent, 'Value delete' value }
  - else:
    - unique { :code code, null parent, 'Else value delete' value }
- :result
```

### Doing http call

Http call can be made based on action context and result can be used in further steps.
Following parameters can be provided:

* conformTo - expected response (`as forest`) **TODO** 
* method - http method (`get`, `post`, `put`, `delete`)
* url - tresql expression that returns url
* body - optional, tresql expression that returns body
* headers - optional, tresql expression that returns headers

**TODO test this example**

```yaml
name: form_urlencoded_test
table:
api: insert, get
fields:
  - name
  - surname
get:
  - res =
      http post
        {'/form_urlencoded_test'}
        { :name name, :surname surname }
        { 'Content-Type', 'application/x-www-form-urlencoded' }
  - :res
insert:
- status ok { :name || ' ' || :surname }
```

Example how to use response from http call to make another http call:

**TODO test this example**

```yaml
name: not_decode_request_insert_test
table:
decode request: false
api: insert, update, get
fields:
- name
get:
- unique { :name name }
insert:
- status ok { if_defined_or_else(:name?, 'error', 'ok') }
update:
- res =
    http post { '/not_decode_request_insert_test' }
      http get {'/not_decode_request_insert_test', '?', 'value' name }
- :res
```

**TODO test this example**

```yaml
name: forest
table: forest
key: nr
api: get, save, list
fields:
- nr
- owner = owner.name -> = owner[name = _] {id}
- area
- trees
save:
- save this as forest http { '/http_forest', '?', :nr nr, :owner owner, :area area, :trees trees }
```
### Sending email and templates

Template generates text from template string and variables by using mustache templating language.  
**TODO** Can I change template language?

> varam nomainīt, template engine jāpameklēt

Template takes following parameters:

* template - template string
* filename - optional filename for attachment, or content-disposition header
* data - By default, it uses context variables, but it can be provided with specif context in `data` parameter.


**TODO test this example**

```yaml
name: template_test1
table:
api: get, list, insert, update, delete
fields:
- name
get:
- res = template 'Hello {{name}}!'
list:
- res = template 'Hello {{title}}. {{name}}!' {:name name, 'Ms' title}
insert:
- res = template 'Hello {{name}}!' filename='file name'
update:
- res = template 'Hello {{name}} in {{action}}!' filename='file name' data={:name name, 'update' action}
delete:
- res = template 'Hello {{name}} in {{action}}!' data={:name name, 'delete' action}
```

To send email you must provide following parameters:

(**TODO** - can we return multiple rows?) 
> > jā, bet varbūt vajag email batch operāciju lai netīšām nenosūta visai datubāzei epastus un defaultais email met eroru ja vairāk kā viena rinda

* emailTresql - tresql select statement that returns data for email 
* subject - subject string for email, the example contains template
* body - body string for email, the example contains template
* attachmentsOp - rest of parameters are list of attachments

Following example sends email with three attachments: 

**TODO test this example**

```yaml
name: email_test1
table:
api: get, insert
fields:
- attachment
get:
- attachment = { 'attachment from http for ' || trim(:name) }
- :attachment
insert:
- file = to file {'attachment from file' attachment} 'file_attachment'
- email
    ({ 'a@a.a' 'to', 'Hannah' name } + { 'b@b.b' 'to', 'Baiba' name })
    (template 'Subject for {{name}}!')
    (template 'Content for {{recipient}}.' {trim(:name) recipient})
    (http { '/email_test1', '?', :name name })
    (file {:file.id, :file.sha_256})
    (template 'Template attachment for {{name}}' {trim(:name) name} 'attachment name')
```

### Scala method call

Scala method may be called from view definition. 

**TODO test this example**

```yaml
name: persona
table: persona
api: get, save, count, delete, create
fields:
- id
- name
- surname
get:
- s3 = org.test.app.PersonManager.personSaveBizMethod
- status ok { :s3 }
```

Scala method receives context as parameter and can return value to be used in view definition.
Context can be defined as scala or java map or dto generated by querease.

Additional parameters can be specified as well: 

* `scala.concurrent.ExecutionContext` - execution context for async operations
* `akka.actor.ActorSystem` - actor system to make actor calls
* `akka.http.scaladsl.model.HttpRequest` - request object that initiated the call
* `org.tresql.Resources` - tresql resources object to get connection to db
* `org.wabase.ResourcesFactory` - factory to get resources
* `org.wabase.FileStreamer` - file streamer to read and write files
* `org.wabase.RequestContext` - request context with parsed user, params ar view name
* `org.wabase.AppQuereaseIo` - querease io object to make db calls and access metadata
* `org.wabase.RequestPartResult` - part of request from `extract parts` statement


Parameters can be defined in arbitrary order as implicit or not.

Result of method can be: 

* `null` or `Unit` - no return value
* `org.tresql.Result` - result of tresql statement
* `org.tresql.RowLike` - result of tresql query
*  Primitives - `Long`, `String`, `java.lang.Number`
* `Dto` - dto generated by querease
* `Option[Dto]` - optional dto generated by querease **TODO** - describe behavior if None
* `Map[String, Any]` - map of values that can be used in view definition
* `akka.http.scaladsl.model.HttpResponse` - http response to be returned to client
* `org.wabase.QuereaseResult` - result of querease operation
* `Iterator[_]`, `Iterable[_]`, `Array[_]` - collection of the above
* `Future[_]` - future of the above, view will wait for future to complete 




**TODO** - Explain how result is assigned to view context (`s3 =` vs `set env` vs `return`)

Examples of method signatures: 

```scala
def personSaveBizMethod(data: Map[String, Any]): Map[String, Any]
def personSaveBizMethod(data: Map[String, Any], request: HttpRequest): Map[String, Any]

def personSaveBizMethod(data: Map[String, Any], request: HttpRequest, resources: Resources): Map[String, Any]
def personSaveBizMethod(data: Map[String, Any])(implicit resources: Resources): Map[String, Any]
def personSaveJavaMapBizMethod(data: java.util.Map[String, Any])

def personSaveBizMethod(data: PersonSaveDto): Future[PersonSaveDto]
```

If parameter is defined as map then full context is passed to method. However specific variable can be passed instead:

**TODO test this example**

```yaml 
name: invocation_test_2
table:
api: get, list, save, delete
key: key
fields:
  - key:
      - initial: "'key_val'"
  - value:
      - initial: "'value_val'"
get:
  - x = create this
  - :x -> org.wabase.QuereaseActionTestManager.rowLikeMethod
```
In this case `->` sign is used to pass variable `x` to method as map.


**TODO** What is `as` statement? :
 
> kāsto uz kādu dto vai listu ar dto 

**TODO test this example**

```yaml
get:
- as any org.wabase.QuereaseActionTestManagerObj.int_array # no special type
```

### Advanced request processing

By default, HTTP POST and PUT requests are decoded and passed as Map of keys and values into context. 
To switch off decoding and process request manually, set `decode request: false` in view definition.
Multipart request can be decoded with `extract parts` statement, it returns list of `RequestPartResult` objects.

`RequestPartResult` contains following fields:

* `name` - name of part
* `contentType` - content type of part
* `filename` - filename of part
* `data` - data of part as `akka.stream.scaladsl.Source[ByteString, Any]`

Example of extracting parts:

**TODO test this example**

```yaml
name: extract_parts_test
decode request: false
table:
key: none
api: insert, update
fields:
- none
  insert:
- res = extract parts
- as any
  { 'field1' name, :res.field1 value } ++
  { 'field2' name, :res.field2 value } ++
  { :res.file1.filename name, :res.file1.sha_256 value } ++
  { :res.file2.filename name, :res.file2.sha_256 value }
  update:
- res = extract parts
- as any unique { :res.filename file, :res.sha_256 sha_256 }
```

**TODO** none key is not needed, but it is needed for now

`RequestPartResult` can be passed to scala class method as well:

**TODO test this example**

```yaml
name: extract_parts_test2
decode request: false
table:
api: insert
insert:
- as any org.wabase.QuereaseActionTestManagerObj.processRequestParts extract parts
```

```scala
def processRequestParts(res: RequestPartResult)(implicit as: ActorSystem, ec: ExecutionContext)
```

## Validations

Validations are used to validate data before it is saved. They can be specified as separate block in view: 

Each validation consists of tresql statement that is executed in context of view and error message. 
If statement returns false, then error message is returned to client with given message.

Within validation block following operations can be used:

* build cursors - creates cursors for nested structures within context that can be used in query
* tuple - where first element is tresql statement that returns boolean value, second is error message
* triple - where first element is tresql statement that prepares data for second element,  second element is tresql statement that returns boolean value, third is error message

**TODO test this example**

```yaml
name: person
api: save, get
table: person
fields:
- id
- name
- surname
- sex
- birthdate
- accounts * :
    table: account
    fields:
    - id
    - number
    - balance
    - last_modified
validations:
  - build cursors
  - ac(# c) { accounts {count(*)} }, (ac{c}) > 0, "person must have at least one account"
```

Or can be specified within action. In this case each validation block can be named. 
In this case validation block can be named and it can be used programmatically in code to generate proper response .

**TODO** - examples of name in response

**TODO test this example**

```yaml
name: payment
api: save, get
table: transaction tr
joins:
- tr[tr.originator_id = originator.id]account originator?
- tr[tr.beneficiary_id = beneficiary.id]account beneficiary?
fields:
- id
- originator  = originator.number  -> = account [number = _] { id }
- beneficiary = beneficiary.number -> = account [number = _] { id }
- amount
- date_time -> = :time :
  - initial: now()
save:
- validations amount:
  - :amount > 0, 'Wrong amount ' || :amount || '. Amount must be greater than 0'
- validations balance:
  - balance(# s) { account[number = :originator] {balance} }, ((balance{s}) = null | (balance{s}) >= :amount),
      "Insufficient funds for account '" || :originator || "'"
- time = now()
- save this
- =account[number = :originator] { balance, last_modified } [balance - :amount, :time]
- =account[number = :beneficiary] { balance, last_modified } [balance + :amount, :time]
- :id
```

