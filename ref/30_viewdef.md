# View deffinition

Views are representation of underlying data structure based on requirements set by 
business logic. Views are used to define how data is presented, saved, deleted.

Where possible view definition is implied and generated from table definition (see [Table definition](ref/20_tabledef.md)) 
and function signatures (see [Function signatures](ref/14_function_signatures.md)).

## General  structure

[Yaml 1.2](https://yaml.org/spec/1.2/) syntax is used for view metadata, but some keys and values are further parsed by mojoz and empty line is used as delimiter.
Key names are:

* **name** - view name
* **table** - table name
* **comments** - view comments
* **api** - collection of APIs view is used for
* **auth** - auth filter statement for horizontal data access control
* **joins** - collection of join statements
* **fields** - collection of fields
* **filter** - collection of filter statements
* **sort** - collection of sort statements

**TODO** - actions and validations

All the statements are written in tresql syntax and 
resulting select, insert, update delete statements are generated by mojoz are as well.

for example, view definition

**TODO test this example**

```yaml
name: user
table: users
comments: This view provides basic users data
api: list, count
fields:
  - id
  - full_name = concat_ws(' ', u.name, u.surname)
filter:
  - email
```

corresponds to following sql: 

```sql
SELECT id, CONCAT_WS(' ', name, surname) AS full_name FROM users WHERE email = ?

SELECT count(*) FROM users WHERE email = ?
```

and savable view: 

**TODO test this example**
```yaml
name: user
table: users
comments: This view provides basic users data
api: save get delete
fields:
  - id
  - name
  - surname
  - email
  - date_of_birth
```

corresponds to following sql: 
    
```sql
SELECT id, name, surname, email, date_of_birth FROM users WHERE id = ?

INSERT INTO users (id, name, surname, email, date_of_birth) VALUES (nextval('seq') ?, ?, ?, ?)

UPDATE users SET name = ?, surname = ?, email = ?, date_of_birth = ? WHERE id = ?
```

## Structure

### Name

View name is used to identify view in the system. It is used in REST API calls and in scala code.

### Table

Name and alias of main table, may not be specified then view name is used.

```yaml
name: user
table: users u
api: list, count
fields: 
    - id
    - name
    - surname
```
results in 

```sql
select u.id, u.name, u.surname from users u
```

but if table is not specified, then view name is used as table name

```yaml
name: user
api: list, count
fields: 
    - id
    - name
    - surname
```

results in 

```sql
select user.id, user.name, user.surname from user
```

### Comments

List of comments for view that can be included in api documentation or just document the code.


**TODO check if multiple comments are supported**


### Api

List of API methods supported by view. Possible values are:

* list - list array of records, default rest path is `/data/{view_name}`
* count - count number of records, default rest path is `/data/count/{view_name}` or `/data/count:{view_name}`
* get - get single record, default rest path is `/data/{view_name}/{id}`
* save - save record, default rest path is `/data/{view_name}` POST for insert and `/data/{view_name}/id` PUT for update
* delete - delete record, default rest path is `/data/{view_name}/{id}` DELETE
* create - create record, default rest path is `/data/create/{view_name}` or `/data/create:{view_name}`


### Auth

Auth filter statement for horizontal data access control statement is added to where clause of select statement. 

```yaml
name: book
table: books b
auth: b.owner_id = :auth_user_id  
api: list, count, get, save, delete
fields:
  - id
  - title
```

results in 

```sql
select b.id, b.title from books b where b.owner_id = :auth_user_id

delete from books where id = :id and owner_id = :auth_user_id

update books set title = :title where id = :id and owner_id = :auth_user_id
```

**TODO** - add insert statement

It is possible to specify separate auth statement for each api method

```yaml
name: book
table: books b
auth list count : b.owner_id = :auth_user_id
auth delete: b.owner_id = :auth_user_id & has_role('admin', :auth_user_id) 
```

### Joins

Collection of join statements in tresql syntax. 

```yaml
name: book
table: books b
joins:
  - b [b.author_id = a.id] author a
  - b [b.genre_id = g.id] genre g
fields:
  - id
  - title
  - author_name = a.name
  - genre_name = g.name
```

results in 

```sql
select b.id, b.title, a.name as author_name, g.name as genre_name from books b
join author a on b.author_id = a.id
join genre g on b.genre_id = g.id
```

### Fields

List of fields withing the view.

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
```

In this case type of field is inferred from table definition.

If needed field type can be specified explicitly:

```yaml 
name: user
table: users u
fields:
    - id       integer
    - name     string
    - surname  string
```

See [Column definition](20_tabledef.md) for more details on type definition.

#### Calculated fields

Calculated fields are fields that are not directly mapped to table columns but are calculated from other fields.

```yaml
name: user
table: users u
fields:
    - id
    - full_name   = concat_ws(' ', u.name, u.surname)
    - age integer = date_part('year', now()) - date_part('year', u.date_of_birth) 
```

Calculated field can be used in save statement as well to store back value sent by client.

```yaml
name: account
table: account
joins: 
  - account [account.bank_id = bank.id] bank
fields:
- id
- code = bank.code -> bank_id = bank[code = :code]{id}
```

Both expressions can be taken from separate view definitions

```yaml
name: bank_choice
table: bank b
fields:
  - id
  - text = concat_ws(' ', b.code, b.name)

name: account
table: account a
joins: 
  - a [account.bank_id = bank.id] bank
fields:
- id
- code = ^bank_choice.text -> = ^bank_choice[^text = _]{id}
```

**TODO** List all shortcut syntaxes for calculated fields

#### Field properties

Beside field name and type, field properties can be specified as well. 

##### Access control
For access control, fields can be fine-tuned: 
Wabase defines two interfaces for fields: 

* between browser and backend `field api`
* between backend and db `field db`

They can be marked as 

* `readonly` - no insert, no update, only return in response
* `no insert` - no insert, but can be updated
* `no update` - can be inserted, but not updated
* `excluded` - not returned in interface

For example,
```yaml
fields:
  - code:
    - field api: readonly
      field db: no update
  - name:
```

Can not be updated from browser, but can be updated from backend on insert.

**TODO** - add more examples


Specific case 'readonly: true' means both interfaces are readonly, these fields have the same access control. 
In this example both fields are readonly for both interfaces.

```yaml
fields:
  - code:
    - field api: readonly
      field db: readonly
  - name:
    - readonly: true
```

##### Sorting

Fields can be marked as sortable, which means they can be used in sort statement in list calls.

```yaml
fields:
  - code:
    - sortable: true
  - name:
```

##### Initial value

Initial value statment can be provided. It will be called when view create api call is called:

```yaml
fields:
  - created_at:
    - initial: now()
```

##### Extended properties

Any other properties can be added to field definition and are passed to field definition in mojoz.

**TODO** - add example


#### Substrcutures

Fields can have nested structures that are defined in separate view definitions. 

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - address [u.address_id = a.id]:
        table: addresses a
        fields:
        - street
        - city
        - country
```

then json returned by get api call will have nested structure:

```json
{
  "id": 1,
  "name": "John",
  "surname": "Doe",
  "address": {
    "street": "Main street",
    "city": "New York",
    "country": "USA"
  }
}
```

Save will be able to save nested structure as well.

If there is only one foreign key from users to address table, then it can be omitted:

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - address:
        table: addresses a
        fields:
        - street
        - city
        - country
```

Substructure can be a list of structures as well:

```yaml
name: book
table: books b
fields:
  - id
  - title
  - authors * [b.id = ba.book_id]:
      table: book_authors ba
      fields:
      - id
      - name
      - surname
      - email
```

Then json returned by get api call will have nested list of structures:

```json
{
  "id": 1,
  "title": "Book title",
  "authors": [
    {
      "id": 1,
      "name": "John",
      "surname": "Doe",
      "email": "jon@foo.com"
    },
    {
      "id": 2,
      "name": "Jane",
      "surname": "Doe",
      "email": "jane@foo.com"
    }
    ]
}
```      

Default behavior on save for nested list of structures is to delete all existing records and insert new ones.
If you want to update existing records, specify it in view definition:

```yaml
name: book
table: books b
fields:
  - id
  - title
  - authors [+-=]* [b.id = ba.book_id]:
      table: book_authors ba
      fields:
      - id
      - name
      - surname
      - email
```

Flags in brackets specify behavior on save:

* `+` - insert new records
* `-` - delete records
* `=` - update records

### Filter

Filter section is used to filter records in list and count api calls. 

Developer can specify fields that can be used for filtering in list and count api calls:

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
filter:
    - name
    - surname
```

Custom filter statement can be provided as well:


```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
filter:
    - name + ' ' + surname like :name
```

For custom statements developer if parameter is optional:

```yaml
filter:
    - name + ' ' + surname like :name?
```

If parameter is not provided, then filter statement will not be included in select query.

To make filter statements more expandable there are macros provided: 

* `if_defined` - if parameter is provided, then filter statement is included
* `if_defined_or_else` - if parameter is provided, then filter statement is included, else other statement is included
* `if_missing` - if parameter is not provided, then filter statement is included

Examples:

**TODO** - write better examples

```yaml
filter:
  - if_defined(:name, name + ' ' + surname like :name)
  - if_defined_or_else(:name, 
      name + ' ' + surname like :name,
      deleted = false) 
  - if_missing(:name, deleted = false)
```

### Sort

Sort section is used to sort records in list and count api calls if user has not provided fields that used in sorting.

Example: 

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
sort:
    - name
    - surname
```

Result is 

```sql
select u.id, u.name, u.surname from users u order by u.name, u.surname
```

Sort can be specified in descending order as well:

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
sort:
    - ~name
    - surname
```

Result is 

```sql
select u.id, u.name, u.surname from users u order by u.name desc, u.surname
```

Expressions can be used in sort as well, and previously defined custom fields:

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - age integer = date_part('year', now()) - date_part('year', u.date_of_birth)
sort:
    - ^age
    - concat_ws(' ', u.name, u.surname)
```
Result is 

```sql
select u.id, u.name, u.surname from users u 
order by 
date_part('year', now()) - date_part('year', u.date_of_birth), 
concat_ws(' ', u.name, u.surname)
```

### Extended properties

Any other properties can be added to view definition and are passed to view definition in mojoz.

**TODO** - add example