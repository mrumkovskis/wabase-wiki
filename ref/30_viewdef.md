# View deffinition

Views are representation of underlying data structure based on requirements set by 
business logic. Views are used to define how data is presented, saved, deleted.

Where possible, view definition is implied and generated from table definition (see [Table definition](ref/20_tabledef.md)) 
and function signatures (see [Function signatures](ref/14_function_signatures.md)).

**TODO** talk about keys

## General  structure

[Yaml 1.2](https://yaml.org/spec/1.2/) syntax is used for view metadata, but some keys and values are further parsed by mojoz and empty line is used as delimiter.
Key names are:

* **name** - view name
* **table** - table name
* **comments** - view comments
* **api** - collection of APIs view is used for
* **auth** - auth filter statement for horizontal data access control
* **joins** - collection of join statements
* **fields** - collection of fields
* **filter** - collection of filter statements
* **order** - collection of order statements

All the statements are written in tresql syntax, and the 
resulting select, insert, update delete statements are generated by mojoz are as well.

for example, view definition

```yaml
name: user_list
table: adm_user l
api: logged_in_user list, logged_in_user count
comments: List of users with their details
fields:
  - id
  - name:
      - sortable: true
      - Name
  - surname:
      - sortable: true
      - Surname
  - phone:
      - Phone
  - status:
      - sortable: true
      - Status
  - email:
      - sortable: true
      - E-mail
filter:
  - email
order:
  - surname, name, ~status
```

corresponds to the following SQL: 

```sql
select l.id, l.name, l.surname, l.phone, l.status, l.email 
from adm_user l 
where l.email = 'test@test.com' 
order by surname asc, name asc, status desc limit 101

select count(*) from adm_user l where l.email = 'test@test.com'
```

and savable view: 

```yaml
name: user_edit
table: adm_user l
api: manage_users get, manage_users save
comments: Edit user details
fields:
  - id
  - name
  - surname
  - position
  - phone
  - status
  - email
  - passwd
  - notes
  - password_expiration_date:
      - field api: readonly
save:
  - password_expiration_date = now() + '90 days'::interval
  - save this
```

corresponds to the following SQL: 
    
```sql
select l.id, l.name, l.surname, l.position, l.phone, l.status, l.email, l.passwd, l.notes, l.password_expiration_date 
from adm_user l where l.id = 20 limit 2

insert into adm_user (name, surname, position, phone, status, email, passwd, notes, password_expiration_date, id) 
values ('Joe', 'Doe', 'Artist', '123', 'Active', 'joe@doe.com', 'fakestreet123', 'Test user', '2025-03-17 08:09:08.172549', '<seq value>')

update adm_user l set 
name = 'Joe', 
surname = 'Doe', 
position = 'Artist', 
phone = '123', 
status = 'Active', 
email = 'joe@doe.com', 
passwd = 'fakestreet123', 
notes = 'Test user', password_expiration_date = '2025-03-17 08:10:45.666989' 
where id = 20
```

## Structure

### Name

View name is used to identify view in the system. It is used in REST API calls and in scala code.

### Table

Name and alias of the main table.

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank clients with their details
  - Must be accessible only to users with role `manage_bank_clients`
fields:
  - id
  - name
  - address
  - phone
  - email
  - last_activity = greatest(date_created, date_updated, last_login) : Last activity
  - initials = substring(name, 1, 1) || substring(surname, 1, 1) : Initials
```
results in 

```sql
select 
  c.id, 
  c.name, 
  c.address, 
  c.phone, 
  c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
limit 101

select count(*) from client c
```

### Comments

List of comments for view that can be included in api documentation or just document the code.

```yaml
name: user_list
table: adm_user l
api: logged_in_user list, logged_in_user count
comments: List of users with their details
```

comments can be multiline as well:

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank clients with their details
  - Must be accessible only to users with role `manage_bank_clients`
```

### Api

List of API methods supported by view and permission required. Possible values are:

* list - list array of records, default rest path is `/data/{view_name}`
* count - count number of records, default rest path is `/data/count/{view_name}` or `/data/count:{view_name}`
* get - get single record, default rest path is `/data/{view_name}/{id}`
* save - save record, default rest path is `/data/{view_name}` POST for insert and `/data/{view_name}/id` PUT for update
* delete - delete record, default rest path is `/data/{view_name}/{id}` DELETE
* create - create record, default rest path is `/data/create/{view_name}` or `/data/create:{view_name}`

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count

name: send_message
table: messages m
api: logged_in_user insert,  logged_in_user get
comments: Send a message to another user

name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count
comments: List of messages sent by the logged in user
```

If api is set to empty, then view is not accessible via REST API directly, but can be used in other views.:

```yaml
name: client_account
table: account a
api:
fields:
  - id
  - balance
  - currency

name: bank_client
table: client c
fields:
  - id
  - name
  - surname
  - accounts * client_account:
```

### Auth

Auth filter statement for the horizontal data access control statement is added to where clause of the select statement. 

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
auth delete: sender_id = :current_user_id & is_read = false
comments: List of messages sent by the logged in user
joins:
  - m [m.attachment_id = f.id] file_info f?
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
  - attachment = f.filename
filter:
  - message %~~~% :message_contains?
```

results in 

```sql
select 
  m.id, 
  (select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver,
  m.subject, 
  m.message, 
  m.time, 
  m.is_read, 
  f.filename as attachment 
from messages m 
left join file_info f on m.attachment_id = f.id 
where (lower(f_unaccent(message)) like '%' || lower(f_unaccent(?/*message_contains*/)) || '%') 
and (sender_id = ?/*current_user_id*/) 
limit ?/*1*/

select count(*) from messages m where (sender_id = ?/*current_user_id*/)

delete from messages m where id = 125 and ((sender_id = 8 and is_read = false))
```

This works for insert and update as well:

```yaml
name: bank_account
table: account a
api: manage_bank_clients list, manage_bank_clients count, manage_bank_clients get, manage_bank_clients save, manage_bank_clients delete
auth save delete: exists(client_manager cm[cm.client_id = a.client_id & cm.user_id = :current_user_id]{1})
comments:
  - List of bank accounts with their details
  - Must be accessible only to users with role `manage_bank_clients`
fields:
  - id
  - client_id
  - number  [+]:
  - balance [+]:
      - field api: readonly
  - currency
  - type
  - date_created [+]:
      - field api: readonly
  - date_closed
insert:
  - date_created = now()
  - balance = 0.0
  - insert this
```

results into:

```sql
insert into account (client_id, number, balance, currency, type, date_created, date_closed, id) 
select a.client_id, a.number, a.balance, a.currency, a.type, a.date_created, a.date_closed, a.id 
from (select 
  ?/*client_id*/::bigint as client_id, 
  ?/*number*/::text as number,
  ?/*balance*/::numeric(12, 2) as balance, 
  ?/*currency*/::text as currency, 
  ?/*type*/::text as type, 
  ?/*date_created*/::date as date_created, 
  ?/*date_closed*/::date as date_closed, 
  ?/*#account:id*/::bigint as id limit 1
  ) a 
where (exists(select 1 from client_manager cm where cm.client_id = a.client_id and cm.user_id = ?/*current_user_id*/))

update account a set 
  client_id = ?/*client_id*/, 
  currency = ?/*currency*/, 
  type = ?/*type*/, 
  date_closed = ?/*date_closed*/ 
where id = ?/*:#account:id*/ 
and ((exists(select 1 from client_manager cm where cm.client_id = a.client_id and cm.user_id = ?/*current_user_id*/)))
```

### Joins

Collection of join statements in tresql syntax. 

```yaml
name: bank_account_list
table: account a
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank accounts with their details
  - Must be accessible only to users with role `manage_bank_clients`
joins:
  - a [a.client_id = c.id] client c
fields:
  - id
  - number
  - balance
  - currency
  - type
  - client_name = c.name || ' ' || c.surname
```

results in 

```sql
select 
  a.id, 
  a.number, 
  a.balance, 
  a.currency, 
  a.type, 
  c.name || ' ' || c.surname as client_name 
from account a 
join client c on a.client_id = c.id 
limit ?/*1*/
```

If left join is required, then the question mark is added to join statement:

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
auth delete: sender_id = :current_user_id & is_read = false
comments: List of messages sent by the logged in user
joins:
  - m [m.attachment_id = f.id] file_info f?
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
  - attachment = f.filename
filter:
  - message %~~~% :message_contains?
```

results in

```sql
select 
  m.id, 
  (select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver,
  m.subject, 
  m.message, 
  m.time, 
  m.is_read, 
  f.filename as attachment 
from messages m 
left join file_info f on m.attachment_id = f.id 
where (lower(f_unaccent(message)) like '%' || lower(f_unaccent(?/*message_contains*/)) || '%') 
and (sender_id = ?/*current_user_id*/) 
limit ?/*1*/
```

If there is only one between tables, then it can be omitted:

```yaml
joins:
  - a / client c
```

Then whether join is left or inner is inferred from table definition - 
if foreign key is nullable, then left join is used, otherwise inner join is used.
However, the join type can be specified explicitly:

* `!` - inner join
* `?` - left join

```yaml
joins:
  - a / client c?
```

or

```yaml
joins:
  - a / client c!
```


### Fields

List of fields withing the view.

```yaml
name: bank_client
table: client c
fields:
  - id
  - name
  - surname
  - address
  - phone
  - email
```

In this case, a type of field is inferred from table definition.

If a necessary field type can be specified explicitly:

```yaml
name: bank_client
table: client c
fields:
  - id        integer
  - name      string
  - surname   string
  - address   string
  - phone     string
  - email     string
  - balance   balance = (account a[a.client_id = c.id]{sum(a.balance)}) : Total balance 
```

See [Column definition](20_tabledef.md) for more details on type definition.

#### Calculated fields

Calculated fields are fields that are not directly mapped to table columns but are calculated from other fields.

```yaml
name: bank_client
table: client c
fields:
  - id        integer
  - balance   balance = (account a[a.client_id = c.id]{sum(a.balance)}) : Total balance 
```

```yaml
name: message_receiver_choice
table: adm_user u
api: logged_in_user list
comments: List of users for user selection
fields:
  - id
  - text = u.name || ' ' || u.surname || ' (' || u.email || ')'
filter:
  - ^text %~~~% :text?
```

Calculated field can be used in a save statement as well to store back value sent by client.

**TODO test this example**

```yaml
name: account
table: account
joins: 
  - account [account.bank_id = bank.id] bank
fields:
- id
- code = bank.code -> bank_id = bank[code = :code]{id}
```

Both expressions can be taken from separate view definitions

```yaml
name: message_receiver_choice
table: adm_user u
api: logged_in_user list
comments: List of users for user selection
fields:
  - id
  - text = u.name || ' ' || u.surname || ' (' || u.email || ')'
filter:
  - ^text %~~~% :text?

name: send_message
table: messages m
api: logged_in_user insert,  logged_in_user get
comments: Send a message to another user
fields:
  - id
  - receiver = ^message_receiver_choice.text -> = ^message_receiver_choice[^text = _]{id}
  - sender_id:
      - field api: excluded
  - subject
  - message
save:
  - sender_id = :current_user_id
  - save this
```

**TODO** List all shortcut syntaxes for calculated fields

> bank_id nevajag rakstīt ja forenā kāja saucas "code" + "_id"
> "_" ir shorthand priekš ":code"
> Vēl ir "dati json = -> = _" gadijums, varbūt strādā tapēc ka nav tāda "dati_id"

#### Field properties

Besides field name and type, field properties can be specified as well. 

##### Access control

**FIXME field db removed, [!]  [+]** 

For access control, fields can be fine-tuned: 
Wabase defines two interfaces for fields: 

* between browser and backend `field api`
* between backend and db `field db`

They can be marked as 

* `readonly` - no insert, no update, only return in response
* `no insert` - no insert, but can be updated
* `no update` - can be inserted, but not updated
* `excluded` - not returned in interface

For example,

**TODO test this example**

```yaml
fields:
  - code:
    - field api: readonly
      field db: no update
  - name:
```

Can not be updated from browser, but can be updated from backend on insert.

**TODO** - add more examples


Specific case 'readonly: true' means both interfaces are readonly, these fields have the same access control. 
In this example both fields are readonly for both interfaces.

**TODO test this example**

```yaml
fields:
  - code:
    - field api: readonly
      field db: readonly
  - name:
    - readonly: true
```

##### Sorting

Fields can be marked as sortable, which means they can be used in a sort statement in list calls.
Doe to possible risks of performance hit not all fields are sortable by default,
user can request only fields that are marked as sortable.

Given this example:

```yaml
name: bank_client_list
table: client c
api: manage_bank_clients list, manage_bank_clients count
comments:
  - List of bank clients with their details
  - Must be accessible only to users with role `manage_bank_clients`
fields:
  - id
  - name:
      - sortable: true
  - address
  - phone
  - email:
      - sortable: true
  - last_activity = greatest(date_created, date_updated, last_login) :
      - Last activity
      - sortable: true
  - initials = substring(name, 1, 1) || substring(surname, 1, 1) :
      - Initials
      - sortable: true
order:
  - id
```

Calling:

```http://localhost:8090/data/bank_client_list```

Will result in:
    
```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
order by id asc 
limit 101
```

Calling 

```http://localhost:8090/data/bank_client_list?sort=name```

Will result in:

```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
order by name asc, id asc 
limit 101
```
You can use multiple fields in sort statement:

```http://localhost:8090/data/bank_client_list?sort=name,email```

Will result in:

```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c order by name asc, email asc, id asc 
limit 101
```

You can use calculated fields in sort statement as well:

```http://localhost:8090/data/bank_client_list?sort=last_activity```

Will result in:

```sql
select c.id, c.name, c.address, c.phone, c.email, 
  greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
  substring(c.name,1,1) || substring(c.surname,1,1) as initial
from client c order by last_activity asc, id asc 
limit 101
```

But calling unsortable field will result in error:

```http://localhost:8090/data/bank_client_list?sort=address```

Will result in:

```
400
Bad Request
Not sortable: bank_client_list by address
```
##### Initial value

Initial value statement can be provided. It will be called when view create api call is called:

**TODO test this example**

```yaml
fields:
  - created_at:
    - initial: now()
```

##### Extended properties

Any other properties can be added to field definition and are passed to field definition in mojoz.

**TODO** - add example


#### Substrcutures

Fields can have nested structures that are defined in separate view definitions. 

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - address [u.address_id = a.id]:
        table: addresses a
        fields:
        - street
        - city
        - country
```

then json returned by get api call will have nested structure:

```json
{
  "id": 1,
  "name": "John",
  "surname": "Doe",
  "address": {
    "street": "Main street",
    "city": "New York",
    "country": "USA"
  }
}
```

Save will be able to save nested structure as well.

If there is only one foreign key from users to address table, then it can be omitted:

**TODO test this example**

```yaml
name: user
table: users u
fields:
    - id
    - name
    - surname
    - address:
        table: addresses a
        fields:
        - street
        - city
        - country
```

Substructure can be a list of structures as well:

```yaml
name: client_account
table: account a
api:
fields:
  - id
  - number
  - balance
  - currency
  - type
  - date_created
  - date_closed

name: bank_client
table: client c
fields:
  - id
  - name
  - surname 
  - accounts * client_account:
```

Then json returned by get api call will have nested list of structures:

```json
{
  "id": 31,
  "name": "Ada",
  "surname": "Lovelace",
  "accounts": [
    {
      "id": 36,
      "number": "e8JptEWxkV",
      "balance": 123123,
      "currency": "USD",
      "type": "SAVINGS",
      "date_created": "2024-11-22",
      "date_closed": null
    }
  ]
}
```      

The Default behavior on save for nested lists of structures is to delete all existing records and insert new ones.
If you want to update existing records, specify it in view definition:

```yaml
name: bank_client
table: client c
fields:
  - id
  - name
  - surname
  - accounts [+-=]* client_account:
```

Flags in brackets specify behavior on save:

* `+` - insert new records
* `-` - delete records
* `=` - update records

For this to work, the primary key of nested structure must be provided in view definition and sent back by client.

### Filter

The Filter section is used to filter records in a list and count api calls. 

Developers can specify fields that can be used for filtering in a list and count api calls:

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
filter:
  - is_read
```

By default filter is not included in a select statement, but if a filter is provided in api call, then it is included:

Query 
```http://localhost:8090/data/sent_messages```

Results in:

```sql
select 
m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where (sender_id = 8) limit 101
```

But if filter is provided:

```http://localhost:8090/data/sent_messages?is_read=true```

Results in:

```sql
select 
m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where (m.is_read = true) 
and (sender_id = 8) limit 101
```

As it is with sorting fields,
only fields that are marked as filterable can be used in a filter statement since it can cause performance issues.


Custom filter statement can be provided as well:

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
fields:
  - id
  - receiver = ^message_receiver_choice.text
  - subject
  - message
  - time
  - is_read
filter:
  - message %~~~% :message_contains?
```

Results in:

```sql
select m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where 
(lower(f_unaccent(message)) like '%' || lower(f_unaccent('hello')) || '%') 
and (sender_id = 8) 
limit 101
```

Question mark is used to specify that filter is optional. Marking optional parameters can only go so far,
it only excludes statement parameter is used in.

For example, this **bad** example:

```yaml
filter:
  - exists(adm_user a[a.id = m.receiver_id & a.email = :username?]{1})
```

Results in:

```sql
where (exists(select 1 from adm_user a where a.id = m.receiver_id)) 
```

or with parmeter:

```http://localhost:8090/data/sent_messages?username=cm%40localhost```


```sql
where (exists(select 1 from adm_user a where a.id = m.receiver_id and a.email = 'cm@localhost'))
```

Proper way to remove an unnecessary filter statement in this case is to use `if_defined` macro:

```yaml
filter:
  - if_defined(:username, exists(adm_user a[a.id = m.receiver_id & a.email = :username?]{1}))
```

Macros are called during sql creation and can be used to modify statement.
Now when username is not provided, a filter statement is not included:

```sql
where (sender_id = 8) 
limit 101
```

Query with parameter remains the same:


```sql
 where (exists(select 1 from adm_user a where a.id = m.receiver_id and a.email = 'cm@localhost')) 
 and (sender_id = 8) 
 limit 101
```


To make filter statements more expandable, there are more macros provided: 

* `if_defined` - if parameter is provided, then a filter statement is included
* `if_defined_or_else` - if parameter is provided, then a filter statement is included, else another statement is included
* `if_missing` - if parameter is not provided, then a filter statement is included
* `if_all_defined` - if all parameters are provided, then a filter statement is included
* `if_any_defined` - if any parameter is provided, then a filter statement is included
* `if_all_missing` - if all parameters are not provided, then a filter statement is included
* `if_any_missing` - if any parameter is not provided, then a filter statement is included

Examples:

```yaml
filter:
  - if_defined(:name_if_def, name = :name_if_def)
  - if_defined_or_else(:name_if_def_or_else, name = :name_if_def_or_else, true)
  - if_missing(:name_if_miss, true)
  - if_all_defined(:name_if_all_def, :surname_if_all_def, name = :name_if_all_def & surname = :surname_if_all_def)
```

### Order

Order section is used to sort records in a list.

Example: 

```yaml
name: sent_messages
table: messages m
api: logged_in_user list, logged_in_user count, logged_in_user delete
auth list: sender_id = :current_user_id
fields:
  - id
  - receiver = ^message_receiver_choice.text:
      - sortable: true
  - subject
  - message
  - time
  - is_read
order:
  - is_read
  - ~time
```

The Result is 

```sql
select m.id, 
(select u.name || ' ' || u.surname || ' (' || u.email || ')' as text from adm_user u where u.id = m.receiver_id) as receiver, 
m.subject, 
m.message, 
m.time, 
m.is_read, 
from messages m 
where (sender_id = 8) 
order by is_read asc, time desc limit 101
```

If a user provides a sort field, then it is added to the list of sort fields as priority:

```http://localhost:8090/data/sent_messages?sort=receiver```

results in: 

```sql
order by receiver asc, is_read asc, time desc
```

`~` at the start of field name means descending order, otherwise ascending order is used. It can be added in parameters as well:


```http://localhost:8090/data/sent_messages?sort=~receiver```

results in:

```sql
order by receiver desc, is_read asc, time desc
```


Expressions can be used in order as well, and previously defined custom fields:

```yaml
name: bank_client_list
table: client c
fields:
  - id
  - name
  - address
  - phone
  - email
  - last_activity = greatest(date_created, date_updated, last_login)
  - initials = substring(name, 1, 1) || substring(surname, 1, 1)
order:
  - last_activity
  - id
```

The Result is 

```sql
select c.id, c.name, c.address, c.phone, c.email, 
greatest(c.date_created,c.date_updated,c.last_login) as last_activity, 
substring(c.name,1,1) || substring(c.surname,1,1) as initials 
from client c 
order by last_activity asc, id asc limit 101
```

### Extended properties

Both view and field definitions can have extended properties that are passed to mojoz and are accessible in the code.
This can be used to extend view functionality declaratively.

First, extra fields must be declared when creating Querease. It is done in scala code: 

```scala
object App
  extends AppBase[user_principal]
...
{

  protected def initQuerease: org.wabase.AppQuerease = new org.wabase.AppQuerease {
    override lazy val knownFieldExtras = KnownFieldExtras() + "can_copy"
    override lazy val knownViewExtras = KnownViewExtras() + "can_copy"
  }

...
}
```

Then in view definition, it can be used:

```yaml
name: classifier_item_choice
table: classifier_item i
api: logged_in_user list
can_copy: true
limit: 9999
joins:
  - i/classifier k
fields:
  - id
  - code:
      - can_copy: true
  - name = i.name:
      - can_copy: true
  - cla_code = k.code
  - code_sort = i.code_sort
```

And in scala code, it can be accessed in `extras: Map[String, Any]`:

```scala
// Lists all views that can be copied with all fields that can be copied
App.qe.nameToViewDef.values.filter(_.extras.getOrElse("can_copy", false).asInstanceOf[Boolean]).foreach { v =>
  logger.debug(s"View ${v.name} can be copied, with following fields: ")
  v.fields.filter(_.extras.getOrElse("can_copy", false).asInstanceOf[Boolean]).foreach { f =>
    logger.debug(s"Field ${f.name} can be copied")
  }
}
```

The Result is in the console:

```log
instance-api-1  | app 26.11.2024 12:32:39.573 DEBUG uniso.app.App  - View classifier_item_choice can be copied, with following fields: 
instance-api-1  | app 26.11.2024 12:32:39.574 DEBUG uniso.app.App  - Field code can be copied
instance-api-1  | app 26.11.2024 12:32:39.574 DEBUG uniso.app.App  - Field name can be copied
```

**TODO** - add example how viewDef class can be extended and don't need to use `extras`